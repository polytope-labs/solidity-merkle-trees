// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.17;

import "forge-std/Test.sol";
import "../src/MerkleMountainRange.sol";

contract MerkleMountainRangeTest is Test {

    function setUp() public {}

    // This unit test showcases how to use the MMR contract
    // to verify a proof generated from the counterpart Rust library.
    function testMerkleMountainRange() public {
        uint256 offset = 0;
        bytes32[] memory data = new bytes32[](5);
        Iterator memory iterator = Iterator(offset, data);

        // Define leaves values
        bytes32 value1 = bytes32(uint256(2));
        bytes32 value2 = bytes32(uint256(5));
        bytes32 value3 = bytes32(uint256(8));
        bytes32 value4 = bytes32(uint256(10));
        bytes32 value5 = bytes32(uint256(12));

        // Push the iterator to the MMR
        MerkleMountainRange.push(iterator, value1);
        MerkleMountainRange.push(iterator, value2);
        MerkleMountainRange.push(iterator, value3);
        MerkleMountainRange.push(iterator, value4);
        MerkleMountainRange.push(iterator, value5);

        assertEq(iterator.offset, 5);

        uint256 leafCount = 14;
        // Proof generated by `merkle_mountain_range.rs` implementation and converted to bytes32:
        bytes32[] memory proof = new bytes32[](7);
        proof[0] = 0xa4a7208a40e95acaf2fe1a3c675b1b5d8c341060e4f179b76ba79493582a95a6;
        proof[1] = 0x989a7025bda9312b19569d9e84e33a624e7fc007e54db23b6758d5f819647071;
        proof[2] = 0xfc5b56233029d71e7e9aff8e230ff491475dee2d8074b27d5fecf8f5154d7c8d;
        proof[3] = 0x37db026959b7bafb26c0d292ecd69c24df5eab845d9625ac5301324402938f25;
        proof[4] = 0x754310be011a7a378b07fa7cbac39dbedcadf645c518ddec58deeaa8c29e0634;
        proof[5] = 0x06be3c46e5a06d7b3e438a9d698f4319dc628624a63e484d97f00b92d09edce7;
        proof[6] = 0x7463c9b814b5d9081938e21346fe8bf81a9a9a0dcfa7bcc03b644a361e395a3b;

        // Leaves generated by `merkle_mountain_range.rs` implementation and converted to MmrLeaf[]:
        MmrLeaf[] memory leaves = new MmrLeaf[](5);
        leaves[0] = MmrLeaf(2, 2, 0x2b97a4b75a93aa1ac8581fac0f7d4ab42406569409a737bdf9de584903b372c5);
        leaves[1] = MmrLeaf(5, 5, 0xd279eb4bf22b2aeded31e65a126516215a9d93f83e3e425fdcd1a05ab347e535);
        leaves[2] = MmrLeaf(0, 8, 0x38e18ac9b4d78020e0f164d6da9ea61b962ab1975bcf6e8e80e9a9fc2ae509f8);
        leaves[3] = MmrLeaf(2, 10, 0x1a3930f70948f7eb1ceab07ecdb0967986091fd8b4b4f447406045431abd9795);
        leaves[4] = MmrLeaf(0, 12, 0xe54ccfb12a140c2dddb6cf78d1c6121610260412c66d00658ed1267863427ab9);

        // Check for calculated vs expected root.
        bytes32 root = CalculateRoot(proof, leaves, leafCount);
        console.logBytes32(root);
        bytes32 expectedRoot = 0x5aac4bad5c6a9014429b7e19ec0e5cd059d28d697c9cdd3f71e78cb6bfbd2600;
        assertEq(root, expectedRoot);

        // Verify the proof
        bool isValid = MerkleMountainRange.VerifyProof(expectedRoot, proof, leaves, leafCount);
        assertTrue(isValid);
    }

    function leavesForPeak(MmrLeaf[] memory leaves, uint64 peak)
        public
        pure
        returns (MmrLeaf[] memory, MmrLeaf[] memory)
    {
        return MerkleMountainRange.leavesForSubtree(leaves, peak);
    }

    function difference(uint256[] memory left, uint256[] memory right) public pure returns (uint256[] memory) {
        return MerkleMountainRange.difference(left, right);
    }

    function siblingIndices(uint256[] memory indices) public pure returns (uint256[] memory) {
        return MerkleMountainRange.siblingIndices(indices);
    }

    function mmrLeafToNode(MmrLeaf[] memory leaves) public pure returns (Node[] memory, uint256[] memory) {
        return MerkleMountainRange.mmrLeafToNode(leaves);
    }

    function CalculateRoot(bytes32[] memory proof, MmrLeaf[] memory leaves, uint256 leafCount)
        public
        pure
        returns (bytes32)
    {
        return MerkleMountainRange.CalculateRoot(proof, leaves, leafCount);
    }
}
